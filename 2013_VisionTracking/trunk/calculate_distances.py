'''
This python module is integrated into the .robo file, and takes the 
list of rectangles generated by the 'Replace_Blobs' filter and 
generates the data we need to later be passed to NetworkTables and
overlay the camera image.

It is currently written in a very simple (possibly non-pythonic) 
style to simplify the process and hopefully lower the processing
time.
'''

from __future__ import division

import math
import rr



### Configuration variables and assumptions ###

# The vertical field of view angle in degrees
VERTICAL_FOV = 39.25

IMAGE_HEIGHT = rr.GetVariable("IMAGE_HEIGHT")

# Each type of vision target has a different length to height ratio.
# This dict contains the ratios of length divided by height, along
# with the corresponding target 'type'
RATIOS = {3.0: 'large', 2.0: 'tiny'}

# The actual heights of the target names (in inches)
EXPECTED_HEIGHT = {'large': 20, 'tiny': 6}

# The names of the actual networktable variables to send.
EXPECTED_NETWORK_TABLE_VARIABLES = [
    ('high', 'large'),
    ('medium1', 'tiny'),
    ('medium2', 'tiny'),
    ('low', 'low')
]


### Utility functions ###

def average(*args):
    '''
    Returns the average of multiple sums.
    
    Usage:
    
        >>> average(4, 2, 4.6, 7)
        4.4
    '''
    return sum(args) / len(args)
    
def closest(target, list_of_nums):
    '''
    Finds the number in a list closest to the target number.
    
    Usage:
    
        >>> closest(5, [1, 2, 6, 8])
        6
    '''
    return min((abs(target - i), i) for i in list_of_nums)[1]
    
def make_variable_name(*args):
    '''
    Takes a sequence of variable parts, and creates a networktable
    variable name.
    
    Usage:
    
        >>> make_variable_name('high', 'centerx')
        'high_centerx'
    '''
    return '_'.join(args)

def get_rectangles():
    '''
    Accesses the Roborealms api and returns a list of dicts.
    Each dict corresponds to a single rectangle/target, and 
    contains information such as the corner coordinates, 
    length and height (in pixels), and the center point.
    
    Relies on the existance of the 'BOUNDING_COORDINATES' 
    variable created by the 'Blob_Replace' filter
    '''
    corners = rr.GetArrayVariable('BOUNDING_COORDINATES')
    output = []
    for i in range(int(len(corners) / 8)):
        rectangle = {}
        p1x = rectangle['top_left_x'] = corners[i * 8 + 0]
        p1y = rectangle['top_left_y'] = corners[i * 8 + 1]
        p2x = rectangle['top_right_x'] = corners[i * 8 + 2]
        p2y = rectangle['top_right_y'] = corners[i * 8 + 3]
        p3x = rectangle['top_right_y'] = corners[i * 8 + 4]
        p3y = rectangle['top_right_y'] = corners[i * 8 + 5]
        p4x = rectangle['top_left_y'] = corners[i * 8 + 6]
        p4y = rectangle['top_left_y'] = corners[i * 8 + 7]
        
        length = rectangle['pixel_length'] = average(p2x - p1x, p3x - p4x)
        height = rectangle['pixel_height'] = average(p2y - p3y, p1y - p4y)
        
        rectangle['center_x'] = int(average(p1x + length/2, p4x + length/2))
        rectangle['center_y'] = int(average(p4y + height/2, p3y + height/2))
        
        output.append(rectangle)
    return output
    
def add_rectangle_type(rectangles):
    '''
    Mutates the rectangles inside the list and adds the 'type' of the 
    rectangle based on the ratio of the length and the height.
    '''
    new_rectangle_list = []
    for rectangle in rectangles:
        if rectangle['pixel_height'] == 0:
            continue
        ratio = float(rectangle['pixel_length']) / float(rectangle['pixel_height'])
        rect_type = RATIOS[closest(ratio, RATIOS.keys())]
        rectangle['type'] = rect_type
        new_rectangle_list.append(rectangle)
    return new_rectangle_list
    
def add_distance(rectangles):
    '''
    Mutates the rectangles inside the list and calculates the 
    distance based on the expected height and actual pixel height.
    
    Relies on the VERTICAL_FOV variable to be correctly set.
    '''
    new_rect_list = []
    for rect in rectangles:
        target_height = EXPECTED_HEIGHT[rect['type']]
        pixel_height = rect['pixel_height']
        # I copied this equation from the example VB script provided
        # by roborealms. I tried simplifying it, but got lost in the 
        # sea of parenthesis.
        distance_inches = (((target_height*IMAGE_HEIGHT)/pixel_height)/2.0) / math.tan(((VERTICAL_FOV*3.14159)/180.0)/2.0)
        rect['distance'] = distance_inches
        rect['distance_feet'] = distance_inches / 12.0
        new_rect_list.append(rect)
    return new_rect_list

def set_variables(name, center_x, center_y, distance):
    '''
    Uses the Roborealm api to set the variables to later be
    used by NetworkTables.
    '''
    rr.SetArrayVariable(name, [center_x, center_y, distance])
    
def create_variables(rectangles):
    '''
    Uses the Roborealm api to set the variables to later be
    used to augment the image to display the rectangle and center
    coordinates.
    '''
    for rect in rectangles:
        rr.SetVariable(make_variable_name(rect['type'], 'center', 'x'), rect['center_x'])
        rr.SetVariable(make_variable_name(rect['type'], 'center', 'y'), rect['center_y'])
        rr.SetVariable(make_variable_name(rect['type'], 'distance'), rect['distance_feet'])
        #rr.SetVariable(make_variable_name(rect['type'], 'rect_type'), rect['type'])
    return rectangles
        
def create_networktable_variables(rectangles):
    '''
    Takes the rectangle dict and creates the variables to be used by
    network tables. This function takes the rectangle type, and 
    matches it to the expected output, accounting for the two duplicate
    medium goals.
    
    It currently passes the center coordinates and the distance.
    
    If an expected goal is not found, the center coordinates and 
    distance is set to 0
    '''
    for var, rect_type in EXPECTED_NETWORK_TABLE_VARIABLES:
        rect_index = None
        current_rect = None
        for index, rect in enumerate(rectangles):
            if rect['type'] == rect_type:
                rect_index = index
                current_rect = rect
                break
        if rect_index is None:
            set_variables(var, 0, 0, 0)
        else:
            set_variables(
                var, 
                current_rect['center_x'], 
                current_rect['center_y'], 
                current_rect['distance'])
            del rectangles[rect_index]
    return rectangles
            
    
def main():
    rectangles = add_distance(add_rectangle_type(get_rectangles()))
    create_variables(rectangles)
    create_networktable_variables(rectangles)

main()